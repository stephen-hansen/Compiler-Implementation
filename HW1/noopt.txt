data:
global array vtblFOO: { m1FOO }
global array fieldsFOO: { 2, 3, 4, 5 }
code:

m1FOO(%this, %x, %y, %z):
  %p = 1
  %q = 1
  # !this.a = x
  %1 = %this & 1
  if %1 then badpointer1 else l1
badpointer1:
  fail NotAPointer
l1:
  %2 = %this + 8
  %3 = load(%2)
  %4 = getelt(%3, 0)
  if %4 then l2 else badfield1
l2:
  %5 = setelt(%this, %4, %x)
  # return 5
  ret 11
badfield1:
  fail NoSuchField

main:
  %x = 1
  %y = 1
  %z = 1
  # z = (1 + (x - (^&@FOO.b.m1(2,y,(z * 3)) / 4)))
  # (z * 3)
  %6 = %z & 1
  if %6 then l3 else badnumber1
l3:
  %7 = %z / 2
  %8 = 7 / 2
  %9 = %7 * %8
  %10 = %9 * 2
  %11 = %10 + 1
  # @FOO
  %12 = alloc(6)
  store(%12, @vtblFOO)
  %13 = %12 + 8
  store(%13, @fieldsFOO)
  # &@FOO.b
  %14 = %12 + 8
  %15 = load(%14)
  %16 = getelt(%15, 1)
  if %16 then l4 else badfield2
l4:
  %17 = getelt(%12, %16)
  # ^&@FOO.b.m1(2,y,(z * 3))
  %18 = %17 & 1
  if %18 then badpointer2 else l5
badpointer2:
  fail NotAPointer
l5:
  %19 = load(%17)
  %20 = getelt(%19, 0)
  if %20 then l6 else badmethod1
l6:
  %21 = call(%20, %17, 5, %y, %11)
  # (^&@FOO.b.m1(2,y,(z * 3)) / 4)
  %22 = %21 & 1
  if %22 then l7 else badnumber2
l7:
  %23 = %21 / 2
  %24 = 9 / 2
  %25 = %23 / %24
  %26 = %25 * 2
  %27 = %26 + 1
  # (x - (^&@FOO.b.m1(2,y,(z * 3)) / 4))
  %28 = %x & 1
  if %28 then l8 else badnumber3
l8:
  %29 = %x - %27
  %30 = %29 + 1
  # (1 + (x - (^&@FOO.b.m1(2,y,(z * 3)) / 4)))
  %31 = %30 & 18446744073709551614
  %z = 3 + %31
  %32 = %z & 1
  if %32 then l9 else badnumber4
l9:
  %33 = %z / 2
  # if z: { ... } else { ... }
  if %33 then l10 else l11
l10:
  %34 = %y & 1
  if %34 then l12 else badnumber5
l12:
  %35 = %y / 2
  # ifonly y: { ... }
  if %35 then l13 else l14
l13:
  # print z
  %36 = %z & 1
  if %36 then l15 else badnumber6
l15:
  %37 = %z / 2
  print(%37)
  jump l14
badnumber6:
  fail NotANumber
l14:
  jump l20
badnumber5:
  fail NotANumber
l11:
  jump l16
l16:
  %38 = %x & 1
  if %38 then l17 else badnumber7
l17:
  %39 = %x / 2
  # while x: { ... }
  if %39 then l18 else l19
l18:
  # return z
  ret %z
l19:
  jump l20
l20:
  %40 = 1 / 2
  # if 0: { ... } else { ... }
  if %40 then l21 else l22
l21:
  # return 3
  ret 7
l22:
  # y = (y + 1)
  # (y + 1)
  %41 = %y & 1
  if %41 then l23 else badnumber8
l23:
  %42 = 3 & 18446744073709551614
  %y = %y + %42
  jump l24
l24:
  %43 = 3 / 2
  # if 1: { ... } else { ... }
  if %43 then l25 else l26
l25:
  # z = (z - 1)
  # (z - 1)
  %44 = %z & 1
  if %44 then l27 else badnumber9
l27:
  %45 = %z - 3
  %z = %45 + 1
  jump l28
l28:
  %46 = %x & 1
  if %46 then l29 else badnumber10
l29:
  %47 = %x / 2
  # if x: { ... } else { ... }
  if %47 then l30 else l31
l30:
  # return x
  ret %x
l31:
  # return y
  ret %y
badnumber10:
  fail NotANumber
badnumber9:
  fail NotANumber
l26:
  # return 2
  ret 5
badnumber8:
  fail NotANumber
badnumber7:
  fail NotANumber
badnumber4:
  fail NotANumber
badnumber3:
  fail NotANumber
badnumber2:
  fail NotANumber
badmethod1:
  fail NoSuchMethod
badfield2:
  fail NoSuchField
badnumber1:
  fail NotANumber

